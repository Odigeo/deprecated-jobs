Any application will need a Queue Service to execute jobs asynchronously. Its purpose is to receive
multi-step job descriptions in JSON (essentially consisting of a series of requests to make, e.g. 
"make a PUT to this URL with this body, then a POST to this URL with this body, then a DELETE to this 
URL". The steps are named.
 
The Queue Service accepts the job, enqueues it in a FIFO queue, and immediately returns a QueueJob 
resource to the caller.
 
The QueueJob resource can be polled via GET to check the status of the job. This is a very efficient 
operation since the result is cached aggressively in Varnish. Thus, a web client can poll a QueueJob 
several times a second if necessary, e.g. to update a progress bar or to check for errors.
 
A QueueJob can also be DELETEd from the queue.
 
Use cases: to start an update operation that might take time: book a ticket, send an email, upload and 
thumbnail a photograph, perform a search, etc.


== AsyncJob Workers

Make sure the <tt>/var/run/async_workers</tt> directory exists and is writable.

To start the AsyncJob workers during development:

  ruby lib/async_job_daemons.rb start

To stop them:

  ruby lib/async_job_daemons.rb stop

To run one of them without demonising:

  ruby lib/async_job_daemons.rb run

To see what's in the log directory:

  ls -l /var/run/async_job_workers

To see what the workers are logging:

  tail -f log/development.log


== Sample AsyncJob

The following will create an AsyncJob which will turn to poison after about 35 seconds.
Raising the +retry_exponent+ to 2.5 yields poison in about a minute. Raising it to 3 
extends this to almost 2 minutes.

  AsyncJob.create(
    steps: [{'url' => 'http://127.0.0.1', 'retry_exponent' => 2}],
    credentials: "bWFnbmV0bzp4YXZpZXI=",
    token: "hhhhhhhhhhhhhhh")
